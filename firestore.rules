
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // =============================
    // Helper Functions
    // =============================
    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    // REPLACE 'YOUR_ADMIN_UID_HERE' with your actual admin Firebase UID.
    // For multiple admins, using custom claims (e.g., request.auth.token.admin == true) is recommended.
    function isAdmin() {
      return isAuthenticated() && request.auth.uid == 'QgyeVb3LUgWOkMrakhCUgb5ZtwN2';
    }

    function isTimestampOrNull(value) {
      return value == null || value is timestamp;
    }

    // Validates the structure and initial values for a new user document.
    // Matches the `newUserDoc` structure from `register-form.tsx`.
    function isNewUserDocumentValid(data) {
      let expectedFields = [
        'name', 'email', 'balance', 'tapCountToday', 'lastTapDate',
        'currentEnergy', 'maxEnergy', 'tapPower', 'lastEnergyUpdate',
        'boostLevels', 'lastLoginBonusClaimed', 'referredBy', 'createdAt',
        'photoURL', 'photoStoragePath', 'completedAchievements', 'referralsMadeCount',
        'activeTheme', 'unlockedThemes', 'frenzyEndTime', 'frenzyMultiplier',
        'energySurgeEndTime', 'updatedAt' // Assuming updatedAt is set on create by client as serverTimestamp()
      ];
      return data.keys().hasAll(expectedFields) &&
             data.keys().hasOnly(expectedFields) && // Ensures no extra fields
             data.name is string && data.name.size() > 0 &&
             data.email == request.auth.token.email &&
             (data.balance is number && data.balance >= 0) && // Initial balance or referral bonus
             data.tapCountToday == 0 &&
             data.lastTapDate is string && // Should be new Date().toDateString()
             data.currentEnergy is number && data.currentEnergy >= 0 &&
             data.maxEnergy is number && data.maxEnergy > 0 &&
             data.currentEnergy <= data.maxEnergy * 1.1 && // Allow overfill up to multiplier
             data.tapPower is number && data.tapPower > 0 &&
             data.lastEnergyUpdate == request.time &&
             data.boostLevels is map &&
             isTimestampOrNull(data.lastLoginBonusClaimed) &&
             (data.referredBy == null || data.referredBy is string) &&
             data.createdAt == request.time && // Should be server timestamp from client
             (data.photoURL == null || data.photoURL is string) &&
             (data.photoStoragePath == null || data.photoStoragePath is string) &&
             data.completedAchievements is map &&
             data.referralsMadeCount == 0 &&
             data.activeTheme is string &&
             data.unlockedThemes is list && data.unlockedThemes.size() > 0 && data.unlockedThemes[0] == data.activeTheme &&
             isTimestampOrNull(data.frenzyEndTime) &&
             (data.frenzyMultiplier == null || data.frenzyMultiplier is number) &&
             isTimestampOrNull(data.energySurgeEndTime) &&
             data.updatedAt == request.time; // Should be server timestamp from client
    }

    // Validates fields a user can update on their own document.
    function isUserSelfUpdateValid(requestData, resourceData) {
      let allowedUserUpdateFields = [
        'name', 'photoURL', 'photoStoragePath', 'activeTheme', // Profile updates
        'balance', 'tapCountToday', 'lastTapDate', 'currentEnergy', // Game state updates
        'maxEnergy', 'tapPower', 'lastEnergyUpdate', 'boostLevels', // Game state updates
        'completedAchievements', 'lastLoginBonusClaimed', // Game progress
        'frenzyEndTime', 'frenzyMultiplier', 'energySurgeEndTime', // Temporary effects
        'updatedAt' // Standard update timestamp
      ];
      // User cannot change their email, original creation time, or referral info via general update
      return requestData.email == resourceData.email &&
             requestData.createdAt == resourceData.createdAt &&
             requestData.referralsMadeCount == resourceData.referralsMadeCount &&
             (requestData.referredBy == resourceData.referredBy || (requestData.referredBy == null && resourceData.referredBy == null)) &&
             requestData.keys().hasOnly(resourceData.keys().concat(allowedUserUpdateFields).toSet().toList()) && // No new restricted fields
             request.resource.data.diff(resource.data).affectedKeys().hasOnly(allowedUserUpdateFields) && // Only allowed fields are changing
             requestData.updatedAt == request.time; // Standard update timestamp
    }

    // Validates fields an admin can update on a user document.
    function isAdminUserUpdateValid(requestData, resourceData) {
      // Admin can update most fields for support or management.
      // Still, email and createdAt should ideally remain immutable or handled by specific admin actions.
      return requestData.email == resourceData.email &&
             requestData.createdAt == resourceData.createdAt &&
             requestData.updatedAt == request.time;
    }

    // Basic validation for transaction creation by user
    function isTransactionValidOnCreateByUser(data) {
      return data.userId == request.auth.uid &&
             data.date == request.time &&
             data.amount is number &&
             data.type is string &&
             data.status is string && (data.status == 'pending' || data.status == 'completed');
    }

    // Validates transaction updates by admin
    function isTransactionUpdateValidByAdmin(requestData, resourceData) {
      let allowedAdminTxUpdateFields = ['status', 'adminNotes', 'updatedAt', 'inrAmount', 'paymentDetails', 'paymentMethod']; // Added inrAmount & payment details for redeem
      return requestData.userId == resourceData.userId && // Cannot change original user
             requestData.type == resourceData.type &&     // Cannot change original type
             requestData.amount == resourceData.amount && // Cannot change original amount
             requestData.date == resourceData.date &&     // Cannot change original date
             request.resource.data.diff(resource.data).affectedKeys().hasOnly(allowedAdminTxUpdateFields) &&
             requestData.updatedAt == request.time;
    }

    // Validates support ticket creation by user
    function isSupportTicketValidOnCreateByUser(data) {
      return data.userId == request.auth.uid &&
             data.createdAt == request.time &&
             data.status == 'open' &&
             data.category is string && data.category.size() > 0 &&
             data.description is string && data.description.size() > 0 &&
             data.userName is string &&
             data.userEmail is string;
    }

    // Validates support ticket updates by admin
    function isSupportTicketUpdateValidByAdmin(requestData, resourceData) {
      let allowedAdminTicketUpdateFields = ['status', 'adminResponse', 'updatedAt'];
      return requestData.userId == resourceData.userId &&
             requestData.createdAt == resourceData.createdAt &&
             request.resource.data.diff(resource.data).affectedKeys().hasOnly(allowedAdminTicketUpdateFields) &&
             requestData.updatedAt == request.time;
    }

    // Validates marquee item fields (for admin CRUD)
    function isMarqueeItemValid(data, isCreate) {
      let expectedFields = ['text', 'createdAt', 'updatedAt'];
      if (isCreate) {
        return data.keys().hasAll(['text', 'createdAt']) && data.keys().hasOnly(['text', 'createdAt']) &&
               data.text is string && data.text.size() > 0 &&
               data.createdAt == request.time;
      } else { // Update
        return data.keys().hasOnly(expectedFields) &&
               data.text is string && data.text.size() > 0 &&
               data.createdAt is timestamp && // Should exist from create
               data.updatedAt == request.time;
      }
    }

    // Validates FAQ item fields (for admin CRUD)
    function isFaqItemValid(data, isCreate) {
      let expectedFields = ['question', 'answer', 'category', 'order', 'iconName', 'createdAt', 'updatedAt'];
      if (isCreate) {
        return data.keys().hasAll(['question', 'answer', 'category', 'order', 'createdAt']) &&
               data.keys().hasOnly(['question', 'answer', 'category', 'order', 'iconName', 'createdAt']) && // iconName and createdAt optional
               data.question is string && data.question.size() > 0 &&
               data.answer is string && data.answer.size() > 0 &&
               data.category is string && data.category.size() > 0 &&
               data.order is number &&
               (data.iconName == null || data.iconName is string) &&
               data.createdAt == request.time;
      } else { // Update
         return data.keys().hasOnly(expectedFields) &&
               data.question is string && data.question.size() > 0 &&
               data.answer is string && data.answer.size() > 0 &&
               data.category is string && data.category.size() > 0 &&
               data.order is number &&
               (data.iconName == null || data.iconName is string) &&
               data.createdAt is timestamp && // Should exist from create
               data.updatedAt == request.time;
      }
    }

    function isUserQuestDocValidOnCreate(data) {
        return data.keys().hasOnly(['lastQuestRefresh', 'activeDailyQuestIds']) &&
               data.lastQuestRefresh == request.time &&
               data.activeDailyQuestIds is list;
    }

    function isUserQuestDocValidOnUpdate(requestData, resourceData) {
        return requestData.keys().hasOnly(['lastQuestRefresh', 'activeDailyQuestIds']) &&
               requestData.lastQuestRefresh == request.time &&
               requestData.activeDailyQuestIds is list;
    }

    function isDailyQuestDocValid(data, isCreate) {
        let expectedFields = ['definition', 'progress', 'completed', 'claimed', 'assignedAt', 'lastProgressAt'];
        return data.keys().hasAll(expectedFields) &&
               data.keys().hasOnly(expectedFields) &&
               data.definition is map &&
               data.progress is number && data.progress >= 0 &&
               data.completed is bool &&
               data.claimed is bool &&
               data.assignedAt == (isCreate ? request.time : resource.data.assignedAt) && // assignedAt set on create
               (data.lastProgressAt == null || data.lastProgressAt is timestamp || data.lastProgressAt == request.time);
    }

    // =============================
    // Collection: users
    // =============================
    match /users/{userId} {
      allow get: if isAuthenticated() && (isOwner(userId) || isAdmin());
      allow list: if isAuthenticated(); // For leaderboard and admin user listing

      // More specific read for public profiles by any authenticated user
      allow read: if isAuthenticated() &&
                     (isOwner(userId) || isAdmin() || resource.data.keys().hasAll(['name', 'balance', 'photoURL']));


      allow create: if isOwner(userId) && isNewUserDocumentValid(request.resource.data);

      allow update: if isAuthenticated() &&
                       (
                         (isOwner(userId) && isUserSelfUpdateValid(request.resource.data, resource.data)) ||
                         (isAdmin() && isAdminUserUpdateValid(request.resource.data, resource.data))
                       );

      allow delete: if isAuthenticated() && (isOwner(userId) || isAdmin());
    }

    // =============================
    // Collection: transactions
    // =============================
    match /transactions/{transactionId} {
      allow read: if isAuthenticated() && (isOwner(resource.data.userId) || isAdmin());

      allow create: if isAuthenticated() &&
                       (
                         (isOwner(request.resource.data.userId) && isTransactionValidOnCreateByUser(request.resource.data)) ||
                         isAdmin() // Admin can create transactions, e.g. for manual adjustments
                       );

      allow update: if isAuthenticated() && isAdmin() && isTransactionUpdateValidByAdmin(request.resource.data, resource.data);

      allow delete: if isAuthenticated() && isAdmin(); // Generally, transactions should not be deleted
    }

    // =============================
    // Collection: marquee_items
    // =============================
    match /marquee_items/{itemId} {
      allow read: if isAuthenticated(); // All authenticated users can read marquee items

      allow create: if isAdmin() && isMarqueeItemValid(request.resource.data, true);
      allow update: if isAdmin() && isMarqueeItemValid(request.resource.data, false);
      allow delete: if isAdmin();
    }

    // =============================
    // Collection: faqs
    // =============================
    match /faqs/{faqId} {
      allow read: if isAuthenticated(); // All authenticated users can read FAQs

      allow create: if isAdmin() && isFaqItemValid(request.resource.data, true);
      allow update: if isAdmin() && isFaqItemValid(request.resource.data, false);
      allow delete: if isAdmin();
    }

    // =============================
    // Collection: user_quests
    // =============================
    match /user_quests/{userId} {
      allow read: if isAuthenticated() && (isOwner(userId) || isAdmin());
      allow create: if isOwner(userId) && isUserQuestDocValidOnCreate(request.resource.data);
      allow update: if isOwner(userId) && isUserQuestDocValidOnUpdate(request.resource.data, resource.data);
      allow delete: if isOwner(userId) || isAdmin(); // User can reset their quests, admin can delete for support
    }

    match /user_quests/{userId}/daily_quests/{questId} {
      allow read: if isAuthenticated() && (isOwner(userId) || isAdmin());
      allow create: if isOwner(userId) && isDailyQuestDocValid(request.resource.data, true);
      allow update: if isOwner(userId) && isDailyQuestDocValid(request.resource.data, false);
      allow delete: if isOwner(userId) || isAdmin();
    }

    // =============================
    // Collection: support_tickets
    // =============================
    match /support_tickets/{ticketId} {
      allow read: if isAuthenticated() && (isOwner(resource.data.userId) || isAdmin());

      allow create: if isAuthenticated() && isOwner(request.resource.data.userId) &&
                       isSupportTicketValidOnCreateByUser(request.resource.data);

      allow update: if isAuthenticated() && isAdmin() &&
                       isSupportTicketUpdateValidByAdmin(request.resource.data, resource.data);

      allow delete: if isAuthenticated() && isAdmin();
    }

    // =============================
    // Default Deny All
    // =============================
    match /{allPaths=**} {
      allow read, write: if false;
    }
  }
}

    