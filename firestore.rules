
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function isAdmin() {
      // Replace with your actual admin UID or use custom claims
      return request.auth.uid == 'QgyeVb3LUgWOkMrakhCUgb5ZtwN2';
    }

    // Validates required fields and types for a new user document
    function isValidNewUserDocument(data) {
      let expectedKeys = [
        'balance', 'tapCountToday', 'lastTapDate', 'currentEnergy', 'maxEnergy',
        'tapPower', 'lastEnergyUpdate', 'boostLevels', 'lastLoginBonusClaimed',
        'referredBy', 'createdAt', 'name', 'email', 'photoURL', 'photoStoragePath',
        'completedAchievements', 'referralsMadeCount', 'activeTheme', 'unlockedThemes',
        'frenzyEndTime', 'frenzyMultiplier', 'energySurgeEndTime'
      ];
      // Ensure 'name' can be null.
      // photoURL and photoStoragePath are also often null initially.
      // referredBy can be null.
      // Timestamps for bonus/frenzy/surge can be null.
      return data.keys().hasAll(expectedKeys) && data.keys().size() == expectedKeys.size()
        && data.balance is number && (data.balance == 0 || data.balance == 10) // 10 is referral bonus
        && data.tapCountToday is number && data.tapCountToday == 0
        && data.lastTapDate is string // Will be today's date string
        && data.currentEnergy is number // Validate against CONFIG.INITIAL_MAX_ENERGY if it's fixed
        && data.maxEnergy is number     // Validate against CONFIG.INITIAL_MAX_ENERGY if it's fixed
        && data.tapPower is number      // Validate against CONFIG.INITIAL_TAP_POWER if it's fixed
        && data.lastEnergyUpdate == request.time
        && data.boostLevels is map && data.boostLevels.size() == 0
        && (data.referredBy == null || data.referredBy is string)
        && data.createdAt == request.time
        && (data.name == null || data.name is string) // Explicitly allow null for name
        && data.email is string && data.email == request.auth.token.email
        && (data.photoURL == null || data.photoURL is string)
        && (data.photoStoragePath == null || data.photoStoragePath is string)
        && data.completedAchievements is map && data.completedAchievements.size() == 0
        && data.referralsMadeCount is number && data.referralsMadeCount == 0
        && data.activeTheme is string
        && data.unlockedThemes is list && data.unlockedThemes.size() >= 1
        && (data.frenzyEndTime == null || data.frenzyEndTime is timestamp)
        && (data.frenzyMultiplier == null || data.frenzyMultiplier is number)
        && (data.energySurgeEndTime == null || data.energySurgeEndTime is timestamp);
    }

    function isValidUserUpdate(data, existingData) {
      let modifiableByOwner = [
        'balance', 'tapCountToday', 'lastTapDate', 'currentEnergy', 'maxEnergy',
        'tapPower', 'lastEnergyUpdate', 'boostLevels', 'lastLoginBonusClaimed',
        'name', 'photoURL', 'photoStoragePath', 'activeTheme', 'unlockedThemes',
        'frenzyEndTime', 'frenzyMultiplier', 'energySurgeEndTime', 'updatedAt'
      ];
      let immutableFieldsByOwner = ['createdAt', 'email', 'referredBy', 'completedAchievements', 'referralsMadeCount'];

      // Admin can modify more fields
      let modifiableByAdmin = modifiableByOwner.concat(['email', 'referredBy', 'completedAchievements', 'referralsMadeCount', 'name', 'maxEnergy', 'tapPower', 'balance']); // Add more if admin needs direct edit
      let immutableFieldsByAdmin = ['createdAt'];

      // Check immutable fields are not changed by owner
      let ownerNoImmutableChanged = immutableFieldsByOwner.hasAny(field -> data[field] == existingData[field]) == false || data.keys().hasAny(immutableFieldsByOwner) == false;

      // Check admin is not changing admin-immutable fields
      let adminNoImmutableChanged = immutableFieldsByAdmin.hasAny(field -> data[field] == existingData[field]) == false || data.keys().hasAny(immutableFieldsByAdmin) == false;


      // Type checks for common updatable fields
      let typesAreCorrect =
           (data.keys().has('balance') ? data.balance is number : true)
        && (data.keys().has('tapCountToday') ? data.tapCountToday is number : true)
        && (data.keys().has('lastTapDate') ? data.lastTapDate is string : true)
        && (data.keys().has('currentEnergy') ? data.currentEnergy is number : true)
        && (data.keys().has('maxEnergy') ? data.maxEnergy is number : true)
        && (data.keys().has('tapPower') ? data.tapPower is number : true)
        && (data.keys().has('lastEnergyUpdate') ? (data.lastEnergyUpdate == request.time || data.lastEnergyUpdate is timestamp) : true)
        && (data.keys().has('boostLevels') ? data.boostLevels is map : true)
        && (data.keys().has('lastLoginBonusClaimed') ? (data.lastLoginBonusClaimed == request.time || data.lastLoginBonusClaimed == null || data.lastLoginBonusClaimed is timestamp) : true)
        && (data.keys().has('name') ? (data.name is string || data.name == null) : true)
        && (data.keys().has('photoURL') ? (data.photoURL is string || data.photoURL == null) : true)
        && (data.keys().has('photoStoragePath') ? (data.photoStoragePath is string || data.photoStoragePath == null) : true)
        && (data.keys().has('activeTheme') ? data.activeTheme is string : true)
        && (data.keys().has('unlockedThemes') ? data.unlockedThemes is list : true)
        && (data.keys().has('frenzyEndTime') ? (data.frenzyEndTime is timestamp || data.frenzyEndTime == null) : true)
        && (data.keys().has('frenzyMultiplier') ? (data.frenzyMultiplier is number || data.frenzyMultiplier == null) : true)
        && (data.keys().has('energySurgeEndTime') ? (data.energySurgeEndTime is timestamp || data.energySurgeEndTime == null) : true)
        && (data.keys().has('updatedAt') ? (data.updatedAt == request.time || data.updatedAt == null) : true); // Allow null for initial updates not setting it, or require it

      if (isAdmin()) {
        // Admin can update any field in modifiableByAdmin list, respecting immutable ones
        let adminAllowedFieldsChanged = data.keys().hasOnly(modifiableByAdmin.concat(immutableFieldsByAdmin));
        return adminNoImmutableChanged && adminAllowedFieldsChanged && typesAreCorrect;
      }

      // Owner specific checks
      let ownerAllowedFieldsChanged = data.keys().hasOnly(modifiableByOwner.concat(immutableFieldsByOwner));
      return ownerNoImmutableChanged && ownerAllowedFieldsChanged && typesAreCorrect;
    }

    function isPublicUserProfile(userData) {
      // Essential for leaderboard: balance must exist and be a number.
      let hasBalance = userData.keys().has('balance') && userData.balance is number;
      // Name is good for display; allow if string or null (client can handle null).
      let hasValidName = !userData.keys().has('name') || (userData.name is string || userData.name == null);
      // PhotoURL is optional for display.
      let hasValidPhoto = !userData.keys().has('photoURL') || (userData.photoURL is string || userData.photoURL == null);

      return hasBalance && hasValidName && hasValidPhoto;
    }


    // Firestore Rules Start
    match /users/{userId} {
      allow create: if isAuthenticated() && isOwner(userId) && isValidNewUserDocument(request.resource.data);
      allow get: if isAuthenticated() && (
                    isOwner(userId) ||
                    isAdmin() ||
                    isPublicUserProfile(resource.data) // Used for leaderboard
                   );
      allow list: if isAuthenticated(); // Allows querying users for leaderboard
      allow update: if isAuthenticated() && (
                      (isOwner(userId) && isValidUserUpdate(request.resource.data, resource.data)) ||
                      (isAdmin() && isValidUserUpdate(request.resource.data, resource.data))
                    );
      allow delete: if isAdmin();
    }

    match /transactions/{transactionId} {
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid
                      && request.resource.data.date == request.time
                      && request.resource.data.status is string
                      && request.resource.data.amount is number;
      allow read: if isAuthenticated() && (resource.data.userId == request.auth.uid || isAdmin());
      allow list: if isAdmin();
      allow update: if isAdmin()
                      // Admin can ONLY update these specific fields for a transaction
                      && request.resource.data.keys().hasOnly(['status', 'adminNotes', 'updatedAt', 'userId', 'amount', 'type', 'date', 'inrAmount', 'paymentMethod', 'paymentDetails', 'userName', 'userEmail', 'relatedUserId', 'relatedUserName', 'details'])
                      && request.resource.data.status is string // Ensure new status is a string
                      && (request.resource.data.keys().has('adminNotes') ? request.resource.data.adminNotes is string || request.resource.data.adminNotes == null : true)
                      && request.resource.data.updatedAt == request.time
                      // Ensure critical fields are NOT changed by admin during this specific update
                      && request.resource.data.userId == resource.data.userId
                      && request.resource.data.amount == resource.data.amount
                      && request.resource.data.type == resource.data.type
                      && request.resource.data.date == resource.data.date;
      allow delete: if isAdmin();
    }

    match /marquee_items/{itemId} {
      allow read: if isAuthenticated();
      allow list: if isAuthenticated();
      allow create: if isAdmin()
                      && request.resource.data.text is string
                      && request.resource.data.createdAt == request.time;
      allow update: if isAdmin()
                      && request.resource.data.text is string
                      && request.resource.data.keys().hasAll(['text', 'updatedAt']) // Allow only text and updatedAt for update
                      && request.resource.data.updatedAt == request.time;
      allow delete: if isAdmin();
    }

    match /faqs/{faqId} {
      allow read: if isAuthenticated();
      allow list: if isAuthenticated();
      allow create: if isAdmin()
                      && request.resource.data.question is string
                      && request.resource.data.answer is string
                      && request.resource.data.category is string
                      && request.resource.data.order is number;
      allow update: if isAdmin()
                      && request.resource.data.keys().hasOnly(['question', 'answer', 'category', 'order', 'iconName']) // Check only allowed fields
                      && request.resource.data.question is string
                      && request.resource.data.answer is string
                      && request.resource.data.category is string
                      && request.resource.data.order is number
                      && (request.resource.data.keys().has('iconName') ? request.resource.data.iconName is string : true);
      allow delete: if isAdmin();
    }

    match /user_quests/{userId} {
      allow read, write: if isAuthenticated() && isOwner(userId);
      match /daily_quests/{questId} {
         allow read, write: if isAuthenticated() && isOwner(userId)
                          && request.resource.data.definition is map
                          && request.resource.data.definition.criteria is map;
      }
    }

    match /support_tickets/{ticketId} {
      allow create: if isAuthenticated()
                      && request.resource.data.userId == request.auth.uid
                      && request.resource.data.userName is string
                      && request.resource.data.userEmail is string
                      && request.resource.data.category is string
                      && request.resource.data.description is string
                      && request.resource.data.status == 'open'
                      && request.resource.data.createdAt == request.time;
      allow read: if isAuthenticated() && (resource.data.userId == request.auth.uid || isAdmin());
      allow list: if isAdmin();
      allow update: if isAdmin()
                      // Admin can ONLY update these specific fields
                      && request.resource.data.keys().hasOnly(['status', 'adminResponse', 'updatedAt', 'userId', 'userName', 'userEmail', 'category', 'description', 'createdAt'])
                      && request.resource.data.status is string
                      && (request.resource.data.keys().has('adminResponse') ? request.resource.data.adminResponse is string || request.resource.data.adminResponse == null : true)
                      && request.resource.data.updatedAt == request.time
                      // Ensure critical fields are NOT changed
                      && request.resource.data.userId == resource.data.userId
                      && request.resource.data.category == resource.data.category
                      && request.resource.data.description == resource.data.description
                      && request.resource.data.createdAt == resource.data.createdAt;
      allow delete: if isAdmin();
    }

    match /admin_actions/{logId} {
        allow read, list: if isAdmin();
        allow create: if isAdmin()
                        && request.resource.data.adminId == request.auth.uid
                        && request.resource.data.timestamp == request.time;
        allow update, delete: if false;
    }

    match /{document=**} {
      allow read, write: if false;
    }
  }
}

    