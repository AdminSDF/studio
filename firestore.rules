
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper function to check if the request is from an admin.
    // IMPORTANT: Replace 'YOUR_ADMIN_UID_HERE' with your actual admin Firebase UID
    // or implement custom claims for a more robust multi-admin setup.
    function isAdmin() {
      // If using custom claims: return request.auth.token.admin == true;
      return request.auth.uid == 'QgyeVb3LUgWOkMrakhCUgb5ZtwN2'; // Replace with your Admin UID
    }

    // Helper function to check if incoming data for user creation is valid
    function isValidUserCreateData(data, request) {
      let expectedKeys = [
        'balance', 'tapCountToday', 'lastTapDate', 'currentEnergy', 'maxEnergy', 'tapPower', 
        'lastEnergyUpdate', 'boostLevels', 'lastLoginBonusClaimed', 'referredBy', 'createdAt', 
        'name', 'email', 'photoURL', 'photoStoragePath', 'completedAchievements', 'referralsMadeCount', 
        'activeTheme', 'unlockedThemes', 'frenzyEndTime', 'frenzyMultiplier', 'energySurgeEndTime'
      ];
      return request.resource.data.keys().hasAll(expectedKeys) && request.resource.data.keys().size() == expectedKeys.size() &&
             data.name is string &&
             data.email == request.auth.token.email &&
             data.balance is number && // Initial balance (e.g., 0 or referral bonus)
             data.tapCountToday == 0 &&
             data.lastTapDate is string && // Should be today's date string
             data.currentEnergy == data.maxEnergy &&
             data.maxEnergy is number &&
             data.tapPower is number &&
             data.lastEnergyUpdate is timestamp && // Client should send Timestamp.fromDate(now)
             data.createdAt is timestamp &&       // Client should send Timestamp.fromDate(user.metadata.creationTime || now)
             data.boostLevels is map &&
             data.lastLoginBonusClaimed == null && // Or is timestamp if claimed immediately
             (data.referredBy == null || data.referredBy is string) &&
             (data.photoURL == null || data.photoURL is string) &&
             (data.photoStoragePath == null || data.photoStoragePath is string) &&
             data.completedAchievements is map &&
             data.referralsMadeCount is number && data.referralsMadeCount == 0 &&
             data.activeTheme is string &&
             data.unlockedThemes is list && data.unlockedThemes.hasAny([data.activeTheme]) &&
             (data.frenzyEndTime == null || data.frenzyEndTime is timestamp) &&
             (data.frenzyMultiplier == null || data.frenzyMultiplier is number) &&
             (data.energySurgeEndTime == null || data.energySurgeEndTime is timestamp);
    }
    
    // Helper function to check if incoming data fields are allowed for user self-update
    function isAllowedUserUpdateFields(requestData, resourceData) {
      let allowedToChange = [
        'name', 'photoURL', 'photoStoragePath', 'activeTheme', 'unlockedThemes', 
        'balance', 'tapCountToday', 'lastTapDate', 'currentEnergy', 'maxEnergy', 'tapPower', 
        'lastEnergyUpdate', 'boostLevels', 'lastLoginBonusClaimed', 'completedAchievements',
        'frenzyEndTime', 'frenzyMultiplier', 'energySurgeEndTime', 'updatedAt' // updatedAt should be set by serverTimestamp via client
      ];
      return requestData.diff(resourceData).affectedKeys().hasOnly(allowedToChange);
    }

    // Helper function for public user profile fields (for leaderboard/profile views)
    function isPublicUserProfile(userData) {
      // For leaderboard: must have 'balance'. 'name' and 'photoURL' are good too.
      // This is now very lenient for debugging leaderboard.
      // In production, ensure 'name' and 'balance' exist and are correct types.
      return userData != null && userData.keys().has('balance');
    }

    // Users Collection (/users/{userId})
    match /users/{userId} {
      allow get: if request.auth != null && (
                    request.auth.uid == userId || 
                    isAdmin() || 
                    isPublicUserProfile(resource.data) // For public profile/leaderboard views
                  );
      allow list: if request.auth != null; // For leaderboard, admin user listing. Individual doc reads are still checked by 'get'.

      allow create: if request.auth != null && 
                      request.auth.uid == userId &&
                      isValidUserCreateData(request.resource.data, request);

      allow update: if request.auth != null && (
                      ( // User updating their own document
                        request.auth.uid == userId &&
                        isAllowedUserUpdateFields(request.resource.data, resource.data) &&
                        request.resource.data.email == resource.data.email && // Email cannot be changed by user
                        request.resource.data.createdAt == resource.data.createdAt && // Creation time cannot be changed
                        request.resource.data.referralsMadeCount == resource.data.referralsMadeCount && // Referrals count updated by server/admin
                        (request.resource.data.keys().has('updatedAt') ? request.resource.data.updatedAt == request.time : true) // If client sends updatedAt, it must be serverTimestamp
                      ) ||
                      ( // Admin updating any user document
                        isAdmin() &&
                        request.resource.data.email == resource.data.email && 
                        request.resource.data.createdAt == resource.data.createdAt &&
                        (request.resource.data.keys().has('updatedAt') ? request.resource.data.updatedAt == request.time : true)
                        // Admin can update most fields, isAllowedUserUpdateFields can be used or a specific admin list.
                        // For simplicity, allowing admin to update fields covered by isAllowedUserUpdateFields + others like referralsMadeCount
                      )
                    );

      allow delete: if request.auth != null && (request.auth.uid == userId || isAdmin());
    }

    // Transactions Collection (/transactions/{transactionId})
    match /transactions/{transactionId} {
      allow read: if request.auth != null && (resource.data.userId == request.auth.uid || isAdmin());

      allow create: if request.auth != null &&
                      (
                        ( // User creating their own transaction
                          request.resource.data.userId == request.auth.uid &&
                          request.resource.data.date == request.time && 
                          request.resource.data.amount is number && 
                          request.resource.data.type is string &&
                          request.resource.data.status is string &&
                          (request.resource.data.status == 'pending' || request.resource.data.status == 'completed') &&
                          // Check for other required fields based on type if necessary
                          (request.resource.data.type != 'redeem' || (
                            request.resource.data.paymentMethod is string &&
                            request.resource.data.paymentDetails is map &&
                            request.resource.data.inrAmount is number
                          ))
                        ) ||
                        isAdmin() // Admin can create transactions
                      );

      allow update: if request.auth != null && isAdmin() &&
                      // Immutable fields check (ensuring client doesn't try to change them)
                      request.resource.data.userId == resource.data.userId &&
                      request.resource.data.userName == resource.data.userName &&
                      request.resource.data.userEmail == resource.data.userEmail &&
                      request.resource.data.amount == resource.data.amount &&
                      request.resource.data.type == resource.data.type &&
                      request.resource.data.inrAmount == resource.data.inrAmount &&
                      request.resource.data.paymentMethod == resource.data.paymentMethod &&
                      request.resource.data.paymentDetails == resource.data.paymentDetails &&
                      request.resource.data.date == resource.data.date && // `date` is the creation timestamp
                      request.resource.data.details == resource.data.details &&
                      request.resource.data.relatedUserId == resource.data.relatedUserId &&
                      request.resource.data.relatedUserName == resource.data.relatedUserName &&
                      // Allow only 'status', 'adminNotes', 'updatedAt' to be in the diff
                      request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'adminNotes', 'updatedAt']) &&
                      request.resource.data.updatedAt == request.time;


      allow delete: if request.auth != null && isAdmin();
    }

    // Marquee Items Collection (/marquee_items/{itemId})
    match /marquee_items/{itemId} {
      allow read: if request.auth != null; // Authenticated users can read
      allow write: if request.auth != null && isAdmin(); // Only admin can write (create, update, delete)
    }

    // FAQs Collection (/faqs/{faqId})
    match /faqs/{faqId} {
      allow read: if true; // Everyone can read FAQs
      // Admin can manage FAQs (create, update, delete)
      allow write: if request.auth != null && isAdmin(); 
    }

    // User Quests (/user_quests/{userId} and subcollection /user_quests/{userId}/daily_quests/{questId})
    match /user_quests/{userId} {
      allow read, write: if request.auth != null && (request.auth.uid == userId || isAdmin()); 
    }
    match /user_quests/{userId}/daily_quests/{questId} {
      allow read, write: if request.auth != null && (request.auth.uid == userId || isAdmin()); 
    }

    // Support Tickets (/support_tickets/{ticketId})
    match /support_tickets/{ticketId} {
      allow read: if request.auth != null && (resource.data.userId == request.auth.uid || isAdmin());

      allow create: if request.auth != null &&
                      request.resource.data.userId == request.auth.uid &&
                      request.resource.data.createdAt == request.time && // Server timestamp for creation
                      request.resource.data.status == 'open' &&
                      request.resource.data.category is string &&
                      request.resource.data.description is string &&
                      request.resource.data.userName is string &&
                      request.resource.data.userEmail is string;
                      // No adminResponse on create

      allow update: if request.auth != null && isAdmin() &&
                      // Immutable fields check
                      request.resource.data.userId == resource.data.userId &&
                      request.resource.data.userName == resource.data.userName &&
                      request.resource.data.userEmail == resource.data.userEmail &&
                      request.resource.data.category == resource.data.category &&
                      request.resource.data.description == resource.data.description &&
                      request.resource.data.createdAt == resource.data.createdAt &&
                      // Allow only 'status', 'adminResponse', 'updatedAt' to be in the diff
                      request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'adminResponse', 'updatedAt']) &&
                      request.resource.data.updatedAt == request.time;

      allow delete: if request.auth != null && isAdmin();
    }

    // Default Deny for any other paths not explicitly matched above.
    // This is important for security.
    match /{allPaths=**} {
      allow read, write: if false;
    }
  }
}
