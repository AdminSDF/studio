
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    function isAdmin() {
      // IMPORTANT: Replace with your actual Admin UID or use custom claims for production.
      // Example for single admin UID:
      return isAuthenticated() && request.auth.uid == 'QgyeVb3LUgWOkMrakhCUgb5ZtwN2';
      // Example for custom claim:
      // return isAuthenticated() && request.auth.token.admin == true;
    }

    function isTimestampOrNull(value) {
      return value == null || value is timestamp;
    }

    function isNumberOrNull(value) {
      return value == null || value is number;
    }

    function isStringOrNull(value) {
      return value == null || value is string;
    }

    // Validates the data structure for a new user document.
    function isValidNewUserData(data, authEmail, requestTime) {
      let initialBalance = data.referredBy == null ? 0 : 10; // 10 is CONFIG.REFERRAL_BONUS_FOR_NEW_USER
      return data.keys().hasAll([
          'balance', 'tapCountToday', 'lastTapDate', 'currentEnergy', 'maxEnergy', 'tapPower',
          'lastEnergyUpdate', 'boostLevels', 'lastLoginBonusClaimed', 'referredBy', 'createdAt', 'name',
          'email', 'photoURL', 'photoStoragePath', 'completedAchievements', 'referralsMadeCount',
          'activeTheme', 'unlockedThemes', 'frenzyEndTime', 'frenzyMultiplier', 'energySurgeEndTime'
        ]) && data.keys().size() == 22 && // Ensures exactly these 22 fields
        (data.balance == 0 || data.balance == initialBalance) && // Initial balance can be 0 or referral bonus
        data.tapCountToday == 0 &&
        data.lastTapDate is string && // Client sends toDateString()
        data.currentEnergy == data.maxEnergy && // Initial energy
        data.maxEnergy is number && data.maxEnergy > 0 && // e.g., CONFIG.INITIAL_MAX_ENERGY
        data.tapPower is number && data.tapPower > 0 &&   // e.g., CONFIG.INITIAL_TAP_POWER
        data.lastEnergyUpdate == requestTime &&
        data.boostLevels is map && data.boostLevels.size() == 0 &&
        isTimestampOrNull(data.lastLoginBonusClaimed) && // Initially null
        isStringOrNull(data.referredBy) && // Can be null or string
        data.createdAt == requestTime &&
        data.name is string && data.name.size() > 0 &&
        data.email == authEmail &&
        isStringOrNull(data.photoURL) && // Initially null
        isStringOrNull(data.photoStoragePath) && // Initially null
        data.completedAchievements is map && data.completedAchievements.size() == 0 &&
        data.referralsMadeCount == 0 &&
        data.activeTheme is string && // Should be default theme ID
        data.unlockedThemes is list && data.unlockedThemes.size() == 1 && data.unlockedThemes[0] == data.activeTheme &&
        isTimestampOrNull(data.frenzyEndTime) && // Initially null
        isNumberOrNull(data.frenzyMultiplier) && // Initially null
        isTimestampOrNull(data.energySurgeEndTime); // Initially null
    }

    // Validates fields a user can update on their own document.
    function canUserUpdateOwnData(request, existingData) {
      let newEmail = request.resource.data.email;
      let newCreatedAt = request.resource.data.createdAt;
      let newReferredBy = request.resource.data.referredBy;
      let newReferralsMadeCount = request.resource.data.referralsMadeCount;

      let allowedFieldsToUpdate = [
        'name', 'photoURL', 'photoStoragePath', 'activeTheme', 'unlockedThemes',
        'balance', 'tapCountToday', 'lastTapDate', 'currentEnergy', 'maxEnergy',
        'tapPower', 'lastEnergyUpdate', 'boostLevels', 'completedAchievements',
        'lastLoginBonusClaimed', 'frenzyEndTime', 'frenzyMultiplier', 'energySurgeEndTime',
        'updatedAt' // Common field to track updates
      ];

      return request.resource.data.diff(existingData).affectedKeys().hasOnly(allowedFieldsToUpdate) &&
             newEmail == existingData.email && // Email cannot be changed by user
             newCreatedAt == existingData.createdAt && // Creation time cannot be changed
             newReferredBy == existingData.referredBy && // Original referrer should not change
             newReferralsMadeCount == existingData.referralsMadeCount && // ReferralsMadeCount should be server-incremented
             (request.resource.data.updatedAt == null || request.resource.data.updatedAt == request.time); // Optional: ensure updatedAt is server timestamp
    }

    // Validates fields an admin can update on a user document.
    function canAdminUpdateUserData(request, existingData) {
       let newEmail = request.resource.data.email;
       let newCreatedAt = request.resource.data.createdAt;
       // Admin can update most fields except perhaps these critical ones
       return newEmail == existingData.email &&
              newCreatedAt == existingData.createdAt &&
              (request.resource.data.updatedAt == null || request.resource.data.updatedAt == request.time);
    }

    // For public profile views and leaderboard
    function isPublicUserProfile(userData) {
      // Ensure essential fields for leaderboard/public view exist and are of correct basic type
      return userData.keys().hasAll(['name', 'balance']) &&
             userData.name is string &&
             userData.balance is number &&
             (userData.photoURL == null || userData.photoURL is string);
    }

    // Users Collection (/users/{userId})
    match /users/{userId} {
      allow create: if isOwner(userId) && isValidNewUserData(request.resource.data, request.auth.token.email, request.time);

      allow read: if isOwner(userId) ||
                     isAdmin() ||
                     (isAuthenticated() && isPublicUserProfile(resource.data)); // For leaderboard & public profiles

      allow update: if (isOwner(userId) && canUserUpdateOwnData(request, resource.data)) ||
                       (isAdmin() && canAdminUpdateUserData(request, resource.data));

      allow delete: if isOwner(userId) || isAdmin();
    }

    // Validates a new transaction.
    function isValidNewTransaction(data, requestTime) {
      return data.userId == request.auth.uid &&
             data.date == requestTime &&
             data.amount is number &&
             data.type is string && (data.type.size() > 0) &&
             data.status is string && (data.status == 'pending' || data.status == 'completed' || data.status == 'failed');
             // Add more checks for specific transaction types or details if needed
    }

    // Validates fields an admin can update in a transaction.
    function canAdminUpdateTransaction(request, existingData) {
      return request.resource.data.userId == existingData.userId && // Cannot change owner
             request.resource.data.amount == existingData.amount && // Cannot change amount
             request.resource.data.type == existingData.type &&     // Cannot change type
             request.resource.data.date == existingData.date &&     // Cannot change original date
             request.resource.data.diff(existingData).affectedKeys().hasOnly(['status', 'adminNotes', 'updatedAt', 'inrAmount', 'paymentMethod', 'paymentDetails']) && // Admin can update these
             (request.resource.data.updatedAt == null || request.resource.data.updatedAt == request.time);
    }

    // Transactions Collection (/transactions/{transactionId})
    match /transactions/{transactionId} {
      allow create: if (isAuthenticated() && request.resource.data.userId == request.auth.uid && isValidNewTransaction(request.resource.data, request.time)) ||
                       isAdmin(); // Admin can create transactions if needed for adjustments

      allow read: if (isAuthenticated() && resource.data.userId == request.auth.uid) || isAdmin();

      allow update: if isAdmin() && canAdminUpdateTransaction(request, resource.data);

      allow delete: if isAdmin(); // Only admin can delete transactions (use with caution)
    }

    // Marquee Items Collection (/marquee_items/{itemId})
    match /marquee_items/{itemId} {
      allow read: if isAuthenticated(); // Any authenticated user can read
      allow list: if isAuthenticated();

      allow create: if isAdmin() &&
                       request.resource.data.text is string && request.resource.data.text.size() > 0 &&
                       request.resource.data.createdAt == request.time;
      allow update: if isAdmin() &&
                       request.resource.data.text is string && request.resource.data.text.size() > 0 &&
                       request.resource.data.createdAt == resource.data.createdAt && // Don't change original creation time
                       (request.resource.data.updatedAt == null || request.resource.data.updatedAt == request.time);
      allow delete: if isAdmin();
    }

    // FAQs Collection (/faqs/{faqId})
    match /faqs/{faqId} {
      allow read: if true; // Everyone can read FAQs
      allow list: if true;

      allow create, update, delete: if isAdmin(); // Only admin can manage FAQs
    }

    // User Quests (/user_quests/{userId} - main doc for quest refresh tracking)
    match /user_quests/{userId} {
      allow get, list, create, update, delete: if isOwner(userId);
      // allow read: if isOwner(userId) || isAdmin(); // If admin needs to read for support
    }

    // User Quests subcollection (/user_quests/{userId}/daily_quests/{questId})
    match /user_quests/{userId}/daily_quests/{questId} {
      allow get, list, create, update, delete: if isOwner(userId);
      // allow read: if isOwner(userId) || isAdmin(); // If admin needs to read for support
    }

    // Validates a new support ticket.
    function isValidNewSupportTicket(data, requestTime) {
      return data.userId == request.auth.uid &&
             data.userName is string &&
             data.userEmail is string &&
             data.category is string && data.category.size() > 0 &&
             data.description is string && data.description.size() > 0 &&
             data.status == 'open' &&
             data.createdAt == requestTime;
    }

    // Validates fields an admin can update in a support ticket.
    function canAdminUpdateSupportTicket(request, existingData) {
      return request.resource.data.userId == existingData.userId &&
             request.resource.data.createdAt == existingData.createdAt &&
             request.resource.data.diff(existingData).affectedKeys().hasOnly(['status', 'adminResponse', 'updatedAt']) &&
             (request.resource.data.updatedAt == null || request.resource.data.updatedAt == request.time);
    }

    // Support Tickets (/support_tickets/{ticketId})
    match /support_tickets/{ticketId} {
      allow create: if isAuthenticated() && request.resource.data.userId == request.auth.uid && isValidNewSupportTicket(request.resource.data, request.time);

      allow read: if (isAuthenticated() && resource.data.userId == request.auth.uid) || isAdmin();

      allow update: if isAdmin() && canAdminUpdateSupportTicket(request, resource.data);

      allow delete: if isAdmin(); // Only admin can delete tickets
    }

    // Default deny for any other paths not explicitly matched above.
    // This is important for security.
    match /{allPaths=**} {
      allow read, write: if false;
    }
  }
}

    