
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isSignedIn() {
      return request.auth != null && request.auth.uid != null;
    }

    function isOwner(userId) {
      return isSignedIn() && request.auth.uid == userId;
    }

    function isAdmin() {
      return isSignedIn() && request.auth.token.admin == true;
    }

    // Function to check if the document represents a public user profile (for listing/reading by others)
    // Ensures essential fields for public display are present and correctly typed.
    function isPublicUserProfile(userData) {
      return userData.balance is number &&
             (userData.name is string || userData.name == null) && // Name can be string or null
             (userData.photoURL is string || userData.photoURL == null) && // photoURL can be string or null
             (userData.createdAt is timestamp); // Ensure createdAt is a timestamp
    }

    // Validates fields for a new user document creation.
    function isValidNewUserDocument(newData, userId) {
      let initialBoostLevels = {}; // Define as empty map
      let initialCompletedAchievements = {}; // Define as empty map
      let initialUnlockedThemes = ["default_aqua"]; // Default theme must be unlocked

      return isOwner(userId) && // User can only create their own document
             newData.userId == userId && // Correctly set userId on the document itself (redundant if doc ID is userId)
             newData.email == request.auth.token.email &&
             newData.name == request.resource.data.name && // Name can be set by user on creation
             newData.balance == 0 || (newData.referredBy != null && newData.balance == 10) && // Initial balance rules
             newData.tapCountToday == 0 &&
             newData.currentEnergy == 100 && // Assuming CONFIG.INITIAL_MAX_ENERGY
             newData.maxEnergy == 100 &&     // Assuming CONFIG.INITIAL_MAX_ENERGY
             newData.tapPower == 0.1 &&      // Assuming CONFIG.INITIAL_TAP_POWER
             newData.boostLevels == initialBoostLevels &&
             newData.lastLoginBonusClaimed == null &&
             // newData.referredBy can be string or null
             newData.createdAt == request.time && // Must be server timestamp
             newData.lastEnergyUpdate == request.time && // Must be server timestamp
             newData.lastTapDate is string && // Should be set by client to today's date string
             (newData.photoURL == null || newData.photoURL is string) &&
             (newData.photoStoragePath == null || newData.photoStoragePath is string) &&
             newData.completedAchievements == initialCompletedAchievements &&
             newData.referralsMadeCount == 0 &&
             newData.activeTheme == "default_aqua" &&
             newData.unlockedThemes == initialUnlockedThemes &&
             newData.frenzyEndTime == null &&
             newData.frenzyMultiplier == null &&
             newData.energySurgeEndTime == null &&
             (!('updatedAt' in newData) || newData.updatedAt == request.time); // Optional updatedAt on create
    }

    // Owner can only update these specific fields on their own profile.
    // Other fields are managed by game logic / transactions.
    function isAllowedOwnerProfileFieldsUpdate() {
      let allowedToChangeByOwner = ['name', 'photoURL', 'photoStoragePath', 'activeTheme'];
      let changedKeys = request.resource.data.diff(resource.data).affectedKeys();
      let onlyPermittedFieldsAreChanging = changedKeys.hasOnly(allowedToChangeByOwner.concat(['updatedAt']));

      return isOwner(userId) && // Ensure this function is used in a context where userId is defined
             onlyPermittedFieldsAreChanging &&
             request.resource.data.updatedAt == request.time &&
             request.resource.data.email == resource.data.email && // email must not change
             request.resource.data.createdAt == resource.data.createdAt; // createdAt must not change
    }

    // Helper function for P2P recipient update by the sender
    // Ensures only balance is incremented and updatedAt is set.
    function isAllowedP2PRecipientUpdate(newUserData, oldUserData) {
      let changedKeys = newUserData.diff(oldUserData).affectedKeys();
      return changedKeys.hasOnly(['balance', 'updatedAt']) &&
             newUserData.balance > oldUserData.balance && // Ensure balance increased (actual amount checked by transaction)
             newUserData.updatedAt == request.time;
    }


    // Validates fields for a new transaction document.
    function isValidTransactionCreate(newData) {
      let commonValid = newData.amount is number &&
                        newData.type is string &&
                        newData.status is string &&
                        newData.date == request.time && // Transaction date must be server time
                        (newData.userId == request.auth.uid ||
                          (newData.type == 'p2p_receive' && newData.relatedUserId == request.auth.uid && newData.userId != request.auth.uid)
                        );

      let typeSpecificValid = false;
      if (newData.type == 'redeem') {
        typeSpecificValid = newData.status == 'pending' &&
                            newData.paymentMethod is string &&
                            newData.paymentDetails is map &&
                            newData.inrAmount is number && newData.inrAmount > 0 &&
                            newData.userId == request.auth.uid;
      } else if (newData.type == 'booster_purchase') {
        typeSpecificValid = newData.status == 'completed' &&
                            newData.details is string &&
                            newData.userId == request.auth.uid;
      } else if (newData.type == 'daily_bonus') {
        typeSpecificValid = newData.status == 'completed' &&
                            newData.userId == request.auth.uid;
      } else if (newData.type == 'referral_bonus') {
        typeSpecificValid = newData.status == 'completed' &&
                            (newData.details is string || newData.details == null) &&
                            newData.userId == request.auth.uid;
      } else if (newData.type == 'achievement_reward') {
        typeSpecificValid = newData.status == 'completed' &&
                            newData.details is string &&
                            newData.userId == request.auth.uid;
      } else if (newData.type == 'p2p_send') {
        typeSpecificValid = newData.status == 'completed' &&
                            newData.relatedUserId is string && newData.relatedUserId != request.auth.uid &&
                            newData.userId == request.auth.uid &&
                            (newData.relatedUserName is string || newData.relatedUserName == null) &&
                            (newData.userName is string || newData.userName == null);
      } else if (newData.type == 'p2p_receive') {
        typeSpecificValid = newData.status == 'completed' &&
                            newData.relatedUserId == request.auth.uid && // Sender is the relatedUserId
                            newData.userId != request.auth.uid && // Recipient is userId
                            (newData.relatedUserName is string || newData.relatedUserName == null) &&
                            (newData.userName is string || newData.userName == null);
      } else if (newData.type == 'quest_reward') {
        typeSpecificValid = newData.status == 'completed' && newData.details is string &&
                            newData.userId == request.auth.uid;
      } else if (newData.type == 'theme_purchase') {
        typeSpecificValid = newData.status == 'completed' && newData.details is string &&
                            newData.userId == request.auth.uid;
      } else if (newData.type == 'offline_earnings') {
        typeSpecificValid = newData.status == 'completed' &&
                            newData.userId == request.auth.uid;
      } else {
        typeSpecificValid = false; // Unknown type not allowed unless explicitly handled
      }
      return commonValid && typeSpecificValid;
    }

    // Allows admin to update transaction status (e.g., for redeem requests).
    function isAdminTransactionUpdate(newData, oldData) {
      let changedKeys = newData.diff(oldData).affectedKeys();
      return isAdmin() &&
             changedKeys.hasOnly(['status', 'updatedAt']) && // Admin can only change status and updatedAt
             newData.updatedAt == request.time &&
             newData.userId == oldData.userId && // Cannot change owner
             newData.type == oldData.type &&     // Cannot change type
             newData.amount == oldData.amount;   // Cannot change amount
    }

    // Collection Rules
    match /users/{userId} {
      allow read: if isSignedIn() || isAdmin(); // More permissive read needed for P2P and admin user lookups.
                                              // Client should handle what to display.

      allow create: if isValidNewUserDocument(request.resource.data, userId);

      allow update: if isSignedIn() &&
                       ( (isOwner(userId) && isAllowedOwnerProfileFieldsUpdate()) || // Owner updating their allowed fields
                         (isAdmin() && request.resource.data.updatedAt == request.time) || // Admin can update any field (carefully)
                         (!isOwner(userId) && isAllowedP2PRecipientUpdate(request.resource.data, resource.data)) // P2P update by sender
                       );
      allow delete: if isAdmin(); // Only admin can delete user documents
    }

    match /transactions/{transactionId} {
      allow read: if isSignedIn() && (isOwner(resource.data.userId) || isAdmin());
      allow create: if isSignedIn() && isValidTransactionCreate(request.resource.data);
      allow update: if isAdminTransactionUpdate(request.resource.data, resource.data);
      allow delete: if isAdmin();
    }

    match /marquee_items/{itemId} {
      allow read: if true; // Marquee items are public
      allow list: if true;
      allow create, update, delete: if isAdmin();
    }

    match /faqs/{faqId} {
      allow read: if true; // FAQs are public
      allow list: if true;
      allow create, update, delete: if isAdmin();
    }

    match /support_tickets/{ticketId} {
      allow read: if isSignedIn() && (isOwner(resource.data.userId) || isAdmin());
      allow create: if isSignedIn() &&
                     request.resource.data.userId == request.auth.uid &&
                     request.resource.data.status == 'open' &&
                     request.resource.data.createdAt == request.time &&
                     request.resource.data.category is string &&
                     request.resource.data.description is string &&
                     request.resource.data.userName is string &&
                     request.resource.data.userEmail is string &&
                     !('adminResponse' in request.resource.data) && // User cannot set admin response on create
                     !('updatedAt' in request.resource.data); // User cannot set updatedAt on create
      allow update: if isAdmin() &&
                     request.resource.data.userId == resource.data.userId && // Cannot change ticket owner
                     request.resource.data.updatedAt == request.time &&
                     // Admin can update status and adminResponse
                     request.resource.data.keys().hasAll(['status', 'adminResponse', 'updatedAt',
                                                          'userId', 'userName', 'userEmail', 'category', 'description', 'createdAt']); // Ensure no other fields added
      allow delete: if isAdmin();
    }

    match /user_quests/{userId} {
      allow read, write: if isOwner(userId) || isAdmin();
      match /daily_quests/{questId} {
        allow read, write: if isOwner(userId) || isAdmin();
      }
    }

    match /admin_actions/{logId} {
      allow read: if isAdmin();
      allow list: if isAdmin();
      allow create: if isAdmin() &&
                     request.resource.data.adminId == request.auth.uid &&
                     request.resource.data.timestamp == request.time;
      // No update/delete for logs by default, unless specifically needed.
      allow update, delete: if false;
    }
  }
}

    