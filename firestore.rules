
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isOwner(userId) {
      return request.auth != null && request.auth.uid == userId;
    }

    function isAdmin() {
      return request.auth != null && request.auth.token.admin == true;
    }

    function isPublicUserProfile(userData) {
      return userData.balance is number &&
             (userData.name is string || userData.name == null) &&
             (userData.photoURL is string || userData.photoURL == null) &&
             (userData.tapPower is number || userData.tapPower == null) &&
             (userData.maxEnergy is number || userData.maxEnergy == null) &&
             (userData.referralsMadeCount is number || userData.referralsMadeCount == null) &&
             (userData.activeTheme is string || userData.activeTheme == null);
    }

    function isValidNewUserDocument(newData) {
      let initialBoostLevels = {};
      CONFIG.BOOSTERS.forEach(booster => initialBoostLevels[booster.id] = 0);

      return newData.balance == 0 || newData.balance == CONFIG.REFERRAL_BONUS_FOR_NEW_USER &&
             newData.tapCountToday == 0 &&
             newData.lastTapDate is string && // Ensure it's set to today's date string by client
             newData.currentEnergy == CONFIG.INITIAL_MAX_ENERGY &&
             newData.maxEnergy == CONFIG.INITIAL_MAX_ENERGY &&
             newData.tapPower == CONFIG.INITIAL_TAP_POWER &&
             newData.lastEnergyUpdate is timestamp && // Validated by client to be now
             newData.boostLevels == initialBoostLevels &&
             newData.lastLoginBonusClaimed == null &&
             (newData.referredBy is string || newData.referredBy == null) &&
             newData.createdAt is timestamp && // Validated by client to be now
             newData.name is string && newData.name.size() > 0 &&
             newData.email == request.auth.email &&
             (newData.photoURL == null || newData.photoURL is string) &&
             newData.photoStoragePath == null &&
             newData.completedAchievements == {} &&
             newData.referralsMadeCount == 0 &&
             newData.activeTheme == CONFIG.APP_THEMES[0].id &&
             newData.unlockedThemes == [CONFIG.APP_THEMES[0].id] &&
             newData.frenzyEndTime == null &&
             newData.frenzyMultiplier == null &&
             newData.energySurgeEndTime == null &&
             newData.size() == 19; // Ensure no extra fields
    }

    function isAllowedOwnerProfileFieldsUpdate(currentData, newData) {
      let allowedFields = ['name', 'photoURL', 'photoStoragePath', 'activeTheme', 'updatedAt'];
      let systemManagedFields = ['email', 'createdAt', 'balance', 'tapPower', 'maxEnergy', 'currentEnergy', 'referredBy', 'referralsMadeCount', 'boostLevels', 'completedAchievements', 'unlockedThemes', 'lastTapDate', 'tapCountToday', 'lastLoginBonusClaimed', 'lastEnergyUpdate', 'frenzyEndTime', 'frenzyMultiplier', 'energySurgeEndTime'];
      
      let allUpdatedKeysAreAllowed = newData.keys().hasAll(allowedFields) || newData.keys().hasOnly(allowedFields);
      let noSystemFieldsChanged = !systemManagedFields. κάποιος(field => currentData[field] != newData[field]);

      return request.auth.uid == currentData.userId && // Check if this is needed or if userId is the doc id
             (newData.name is string || newData.name == null) &&
             (newData.photoURL is string || newData.photoURL == null) &&
             (newData.photoStoragePath is string || newData.photoStoragePath == null) &&
             (newData.activeTheme is string && CONFIG.APP_THEMES. κάποιος(theme => theme.id == newData.activeTheme) && newData.unlockedThemes.hasAny([newData.activeTheme])) &&
             newData.updatedAt == request.time &&
             allUpdatedKeysAreAllowed && 
             noSystemFieldsChanged;
    }

    // Matches any document in the 'users' collection.
    match /users/{userId} {
      allow get: if request.auth != null && (isOwner(userId) || isAdmin() || isPublicUserProfile(resource.data));
      allow list: if request.auth != null; // Leaderboard needs this, individual docs checked by `get` rule
      allow create: if isOwner(userId) && isValidNewUserDocument(request.resource.data);
      allow update: if request.auth != null && 
                      (
                        // Owner can update specific fields
                        (isOwner(userId) && isAllowedOwnerProfileFieldsUpdate(resource.data, request.resource.data)) ||
                        // Admin can update (broader permissions for admin, define more granularly if needed)
                        isAdmin() ||
                        // P2P Transfer: Sender updates recipient's balance
                        (
                          request.auth.uid != userId && // Sender is not the recipient
                          request.resource.data.balance == resource.data.balance + request.resource.data.incomingTransferAmount && // only balance is being incremented by a specific amount
                          request.resource.data.updatedAt == request.time &&
                          request.resource.data.keys().hasOnly(['balance', 'updatedAt', 'incomingTransferAmount']) // Ensure only balance & updatedAt are touched by sender
                        )
                      );
      allow delete: if isAdmin(); // Only admins can delete user accounts
    }

    // Helper: Validates common transaction fields
    function isValidBaseTransaction(data, userId) {
      return data.userId == userId &&
             data.amount is number &&
             data.status is string && (data.status == 'pending' || data.status == 'completed' || data.status == 'failed') &&
             data.date == request.time && // Ensure server timestamp on creation
             (data.details is string || data.details == null) &&
             (data.userName == request.auth.token.name || data.userName == null || data.userName == resource.data.name) && // resource.data.name for recipient in p2p
             (data.userEmail == request.auth.token.email || data.userEmail == null || data.userEmail == resource.data.email); // resource.data.email for recipient in p2p
    }
    
    function isValidPaymentDetails(details, method) {
        let valid = false;
        if (method == 'upi') {
            valid = details.upiId is string && details.upiId.matches('.*@.*') && details.upiName is string && details.size() == 2;
        } else if (method == 'bank') {
            valid = details.accNumber is string && details.confirmAcc == details.accNumber &&
                    details.ifsc is string && details.ifsc.size() == 11 &&
                    details.accName is string && details.bankName is string && details.size() == 5;
        } else if (method == 'paytm' || method == 'googlepay' || method == 'phonepay') {
            valid = details.number is string && details.number.matches('^\\d{10}$') && details.name is string && details.size() == 2;
        }
        return valid;
    }

    function isValidTransactionCreate(data, userId) {
      let commonValid = isValidBaseTransaction(data, userId);
      let typeSpecificValid = false;

      // Redeem
      if (data.type == 'redeem') {
        typeSpecificValid = data.amount > 0 && data.amount >= CONFIG.MIN_REDEEM &&
                            data.inrAmount is number && data.inrAmount == data.amount * CONFIG.CONVERSION_RATE &&
                            data.paymentMethod is string && isValidPaymentDetails(data.paymentDetails, data.paymentMethod) &&
                            data.status == 'pending' && data.size() == 9; // userId, amount, type, status, date, paymentMethod, paymentDetails, inrAmount, details?
      }
      // Booster Purchase
      else if (data.type == 'booster_purchase') {
        typeSpecificValid = data.amount > 0 && data.status == 'completed' && data.details is string && data.size() == 6;
      }
      // Daily Bonus
      else if (data.type == 'daily_bonus') {
        typeSpecificValid = data.amount == CONFIG.DAILY_LOGIN_BONUS && data.status == 'completed' && data.size() == 5;
      }
      // Referral Bonus (generic, used for new user and milestones)
      else if (data.type == 'referral_bonus') {
        typeSpecificValid = data.amount > 0 && data.status == 'completed' && data.details is string && data.size() == 6;
      }
      // Achievement Reward
      else if (data.type == 'achievement_reward') {
        typeSpecificValid = data.amount > 0 && data.status == 'completed' && data.details is string && data.size() == 6;
      }
      // Quest Reward
      else if (data.type == 'quest_reward') {
        typeSpecificValid = data.amount > 0 && data.status == 'completed' && data.details is string && data.size() == 6;
      }
      // Theme Purchase
      else if (data.type == 'theme_purchase') {
        typeSpecificValid = data.amount > 0 && data.status == 'completed' && data.details is string && data.size() == 6;
      }
      // Offline Earnings
      else if (data.type == 'offline_earnings') {
        typeSpecificValid = data.amount > 0 && data.status == 'completed' && data.details is string && data.size() == 6;
      }
      // P2P Send (created by sender)
      else if (data.type == 'p2p_send') {
        typeSpecificValid = data.userId == request.auth.uid && // Sender is creating this
                            data.amount > 0 && data.status == 'completed' &&
                            data.relatedUserId is string && data.relatedUserId != request.auth.uid &&
                            (data.relatedUserName is string || data.relatedUserName == null) &&
                            data.size() == 8; // userId, amount, type, status, date, details, relatedUserId, relatedUserName
      }
      // P2P Receive (also created by sender, but for recipient)
      else if (data.type == 'p2p_receive') {
         typeSpecificValid = data.userId != request.auth.uid && // Recipient's ID
                             data.amount > 0 && data.status == 'completed' &&
                             data.relatedUserId == request.auth.uid && // Sender's ID as related
                             (data.relatedUserName is string || data.relatedUserName == null) && // Sender's name
                             data.size() == 8; // userId, amount, type, status, date, details, relatedUserId, relatedUserName
      }
      
      return commonValid && typeSpecificValid;
    }

    match /transactions/{transactionId} {
      allow read: if request.auth != null && (isOwner(resource.data.userId) || isAdmin());
      allow create: if request.auth != null && 
                      (
                        (request.resource.data.type != 'p2p_receive' && isValidTransactionCreate(request.resource.data, request.auth.uid)) ||
                        (request.resource.data.type == 'p2p_receive' && isValidTransactionCreate(request.resource.data, request.resource.data.userId)) // For p2p_receive, userId is recipient
                      );
      allow update: if isAdmin() && 
                      resource.data.type == 'redeem' && 
                      (request.resource.data.status == 'completed' || request.resource.data.status == 'failed') &&
                      request.resource.data.updatedAt == request.time &&
                      request.resource.data.keys().hasAll(['status', 'updatedAt']); // Only allow status and updatedAt to be changed by admin
      allow delete: if isAdmin();
    }

    match /marquee_items/{itemId} {
      allow read: if true; // Publicly readable
      allow list: if true; // Publicly listable
      allow create, update, delete: if isAdmin();
    }

    match /user_quests/{userId} {
      allow read, write: if isOwner(userId) || isAdmin();
    }

    match /user_quests/{userId}/daily_quests/{questId} {
      allow read, write: if isOwner(userId) || isAdmin();
    }

    match /faqs/{faqId} {
      allow read: if true; // Publicly readable
      allow list: if true; // Publicly listable
      allow create, update, delete: if isAdmin();
    }

    match /support_tickets/{ticketId} {
      allow read: if request.auth != null && (isOwner(resource.data.userId) || isAdmin());
      allow create: if request.auth != null && 
                      request.resource.data.userId == request.auth.uid &&
                      request.resource.data.userName == request.auth.token.name &&
                      request.resource.data.userEmail == request.auth.token.email &&
                      request.resource.data.category is string && request.resource.data.category.size() > 0 &&
                      request.resource.data.description is string && request.resource.data.description.size() > 0 &&
                      request.resource.data.status == 'open' &&
                      request.resource.data.createdAt == request.time &&
                      (request.resource.data.adminResponse == null || request.resource.data.adminResponse == "") &&
                      request.resource.data.keys().hasAll(['userId', 'userName', 'userEmail', 'category', 'description', 'status', 'createdAt', 'adminResponse']); 
      allow update: if isAdmin() &&
                      (request.resource.data.adminResponse is string || request.resource.data.adminResponse == null) &&
                      request.resource.data.status is string && (request.resource.data.status == 'open' || request.resource.data.status == 'pending' || request.resource.data.status == 'resolved' || request.resource.data.status == 'closed') &&
                      request.resource.data.updatedAt == request.time &&
                      request.resource.data.keys().hasAll(['adminResponse', 'status', 'updatedAt']);
      allow delete: if isAdmin();
    }

    // Admin Actions Log - Only admins can create and read. No updates/deletes from client.
    match /admin_actions/{logId} {
      allow read, create: if isAdmin();
      allow update, delete: if false; 
    }

  }
}

    