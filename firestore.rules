
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // ==========================================================================================
    // HELPER FUNCTIONS
    // ==========================================================================================
    function isAuthenticated() {
      return request.auth != null;
    }

    function isAdmin() {
      // IMPORTANT: Replace with your actual Admin UID or use custom claims for production.
      // Example with custom claim: return request.auth.token.admin == true;
      return isAuthenticated() && request.auth.uid == 'QgyeVb3LUgWOkMrakhCUgb5ZtwN2';
    }

    function isOwner(userId) {
      return isAuthenticated() && request.auth.uid == userId;
    }

    // Function to check if incoming data for user creation is valid
    function isValidUserCreateData(data, userId) {
      let requiredFields = [
        'name', 'email', 'balance', 'tapCountToday', 'lastTapDate',
        'currentEnergy', 'maxEnergy', 'tapPower', 'lastEnergyUpdate', 'createdAt',
        'boostLevels', 'completedAchievements', 'unlockedThemes', 'activeTheme',
        'referralsMadeCount', 'referredBy', 'photoURL', 'photoStoragePath',
        'frenzyEndTime', 'frenzyMultiplier', 'energySurgeEndTime' // 21 fields total
      ];
      return data.keys().hasAll(requiredFields) &&
             data.keys().size() == 21 && // Ensure no extra fields
             data.name is string && data.name.size() > 0 &&
             data.email == request.auth.token.email &&
             (data.balance is number && data.balance >= 0) &&
             data.tapCountToday is number &&
             data.lastTapDate is string && // Or check format if specific
             data.currentEnergy is number && data.currentEnergy >=0 &&
             data.maxEnergy is number && data.maxEnergy > 0 &&
             data.tapPower is number && data.tapPower > 0 &&
             data.lastEnergyUpdate is timestamp && // Validated against request.time in rule
             data.createdAt is timestamp && // Validated against request.time in rule
             data.boostLevels is map &&
             data.completedAchievements is map &&
             data.unlockedThemes is list &&
             data.activeTheme is string &&
             data.referralsMadeCount is number &&
             (data.referredBy == null || data.referredBy is string) &&
             (data.photoURL == null || data.photoURL is string) &&
             (data.photoStoragePath == null || data.photoStoragePath is string) &&
             (data.frenzyEndTime == null || data.frenzyEndTime is timestamp) &&
             (data.frenzyMultiplier == null || data.frenzyMultiplier is number) &&
             (data.energySurgeEndTime == null || data.energySurgeEndTime is timestamp);
    }

    // Function to check if a user is allowed to update their own document
    function canUpdateOwnUserData(currentData, newData) {
      let allowedToUpdate = [
        'name', 'photoURL', 'photoStoragePath', 'activeTheme', 'unlockedThemes',
        'balance', 'tapCountToday', 'lastTapDate', 'currentEnergy', 'maxEnergy',
        'tapPower', 'lastEnergyUpdate', 'boostLevels', 'completedAchievements',
        'lastLoginBonusClaimed', 'frenzyEndTime', 'frenzyMultiplier', 'energySurgeEndTime',
        'updatedAt' // Common field for tracking updates
      ];
      let forbiddenToUpdate = ['email', 'createdAt', 'referredBy', 'referralsMadeCount']; // Fields user shouldn't change directly

      return newData.keys().hasOnly(allowedToUpdate.concat(forbiddenToUpdate).filter(key => currentData.keys().has(key) || newData.keys().has(key))) && // No new arbitrary fields
             newData.email == currentData.email && // Email cannot be changed by user
             newData.createdAt == currentData.createdAt; // Creation timestamp cannot be changed
             // referralsMadeCount should only be incremented by server/trusted logic
    }

    function isPublicUserProfile(userData) {
      // TEMPORARILY VERY LENIENT FOR DEBUGGING LEADERBOARD
      // This means any authenticated user can read any field of any user document
      // if they are not the owner and not an admin.
      // This should allow the leaderboard query to pass.
      // If it does, then the problem is indeed with stricter checks in a previous isPublicUserProfile
      // and we need to find a balance or ensure data integrity for production.
      return userData is map; // Allows reading any existing document.
    }


    // ==========================================================================================
    // USERS COLLECTION (/users/{userId})
    // ==========================================================================================
    match /users/{userId} {
      allow get: if isAuthenticated() && (
        isOwner(userId) ||
        isAdmin() ||
        isPublicUserProfile(resource.data) // For public profile views by other users
      );

      allow list: if isAuthenticated() && (
        // Authenticated users can list users for leaderboard, etc.
        // The actual documents returned will be further checked by the `get` rule.
        true
      );

      allow create: if isOwner(userId) &&
                      isValidUserCreateData(request.resource.data, userId) &&
                      request.resource.data.lastEnergyUpdate == request.time &&
                      request.resource.data.createdAt == request.time;

      allow update: if isAuthenticated() && (
        (isOwner(userId) && canUpdateOwnUserData(resource.data, request.resource.data) &&
         (request.resource.data.keys().has('updatedAt') ? request.resource.data.updatedAt == request.time : true)
        ) ||
        (isAdmin() && // Admin can update more fields
          request.resource.data.email == resource.data.email && // but not critical ones like email/createdAt
          request.resource.data.createdAt == resource.data.createdAt &&
          (request.resource.data.keys().has('updatedAt') ? request.resource.data.updatedAt == request.time : true)
        )
      );

      allow delete: if isAdmin() || (isOwner(userId)); // User can delete own account (reset), Admin can delete any
    }

    // ==========================================================================================
    // TRANSACTIONS COLLECTION (/transactions/{transactionId})
    // ==========================================================================================
    match /transactions/{transactionId} {
      allow read: if isAuthenticated() && (isOwner(resource.data.userId) || isAdmin());

      allow create: if isAuthenticated() &&
                      request.resource.data.userId == request.auth.uid &&
                      request.resource.data.date == request.time &&
                      request.resource.data.amount is number &&
                      request.resource.data.type is string &&
                      request.resource.data.status is string && (request.resource.data.status == 'pending' || request.resource.data.status == 'completed');

      allow update: if isAdmin() &&
                      request.resource.data.diff(resource.data).affectedKeys().hasOnly(['status', 'adminNotes', 'updatedAt']) &&
                      (request.resource.data.keys().has('updatedAt') ? request.resource.data.updatedAt == request.time : true);

      allow delete: if isAdmin();
    }

    // ==========================================================================================
    // FAQS COLLECTION (/faqs/{faqId})
    // ==========================================================================================
    match /faqs/{faqId} {
      allow read: if true; // Everyone can read FAQs
      allow write: if isAdmin(); // Only admin can create/update/delete FAQs
    }

    // ==========================================================================================
    // MARQUEE ITEMS COLLECTION (/marquee_items/{itemId})
    // ==========================================================================================
    match /marquee_items/{itemId} {
      allow read: if isAuthenticated(); // Authenticated users can read
      allow write: if isAdmin(); // Admin can manage
    }

    // ==========================================================================================
    // USER QUESTS (/user_quests/{userId} and subcollection /user_quests/{userId}/daily_quests/{questId})
    // ==========================================================================================
    match /user_quests/{userId} {
      allow read, write: if isOwner(userId);
      // allow read: if isOwner(userId) || isAdmin(); // Admin read for support
    }
    match /user_quests/{userId}/daily_quests/{questId} {
      allow read, write: if isOwner(userId);
      // allow read: if isOwner(userId) || isAdmin(); // Admin read for support
    }

    // ==========================================================================================
    // SUPPORT TICKETS (/support_tickets/{ticketId})
    // ==========================================================================================
    match /support_tickets/{ticketId} {
      allow read: if isAuthenticated() && (isOwner(resource.data.userId) || isAdmin());

      allow create: if isAuthenticated() &&
                      request.resource.data.userId == request.auth.uid &&
                      request.resource.data.createdAt == request.time &&
                      request.resource.data.status == 'open' &&
                      request.resource.data.category is string && request.resource.data.category.size() > 0 &&
                      request.resource.data.description is string && request.resource.data.description.size() > 0 &&
                      request.resource.data.userName is string &&
                      request.resource.data.userEmail is string;

      allow update: if isAdmin() &&
                      request.resource.data.userId == resource.data.userId &&
                      request.resource.data.createdAt == resource.data.createdAt &&
                      request.resource.data.diff(resource.data).affectedKeys().hasAny(['status', 'adminResponse', 'updatedAt']) &&
                      (request.resource.data.keys().has('updatedAt') ? request.resource.data.updatedAt == request.time : true);

      allow delete: if isAdmin();
    }

    // ==========================================================================================
    // DEFAULT DENY
    // ==========================================================================================
    match /{allPaths=**} {
      allow read, write: if false;
    }
  }
}

    