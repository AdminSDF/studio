
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // --- Helper Functions ---
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function isAdmin() {
      // Ensure 'admin' claim is explicitly true.
      // Checking for 'exists' or '!= null' can be risky if the claim could be set to false.
      return request.auth.token.admin == true;
    }

    function isValidTimestampOrNull(value) {
      return value == null || value is timestamp;
    }

    // Function to check if a user profile can be publicly read (e.g., for leaderboard)
    function isPublicUserProfile(userData) {
      // For leaderboard/public view, we mainly care about display name and balance.
      // photoURL is optional.
      return userData.balance is number &&
             (userData.name is string || userData.name == null) && // Name can be string or null
             (userData.photoURL is string || userData.photoURL == null); // photoURL can be string or null
    }

    // Function to validate the structure and types of a new user document on creation.
    function isValidNewUserDocument(data) {
      // Initial balance can be 0 or the referral bonus amount.
      let isValidBalance = (data.balance == 0 || data.balance == 10); // 10 is CONFIG.REFERRAL_BONUS_FOR_NEW_USER

      return isValidBalance
             && data.tapCountToday == 0
             && data.lastTapDate is string // Client will send today's date string
             && data.currentEnergy is number && data.currentEnergy > 0
             && data.maxEnergy is number && data.maxEnergy > 0
             && data.tapPower is number && data.tapPower > 0
             && data.lastEnergyUpdate == request.time // Must be server timestamp on create
             && data.boostLevels is map && data.boostLevels.size() == 0
             && data.lastLoginBonusClaimed == null // Must be null initially
             && (data.referredBy is string || data.referredBy == null)
             && data.createdAt == request.time // Must be server timestamp on create
             && data.name is string
             && data.email is string
             && data.photoURL == null // Must be null initially
             && data.photoStoragePath == null // Must be null initially
             && data.completedAchievements is map && data.completedAchievements.size() == 0
             && data.referralsMadeCount == 0
             && data.activeTheme is string // Default theme ID
             && data.unlockedThemes is list && data.unlockedThemes.size() == 1 // Only default theme
             && data.frenzyEndTime == null
             && data.frenzyMultiplier == null
             && data.energySurgeEndTime == null
             // Ensure all expected fields are present and no extra fields.
             && data.keys().hasAll(['balance', 'tapCountToday', 'lastTapDate', 'currentEnergy', 'maxEnergy', 'tapPower', 'lastEnergyUpdate', 'boostLevels', 'lastLoginBonusClaimed', 'referredBy', 'createdAt', 'name', 'email', 'photoURL', 'photoStoragePath', 'completedAchievements', 'referralsMadeCount', 'activeTheme', 'unlockedThemes', 'frenzyEndTime', 'frenzyMultiplier', 'energySurgeEndTime'])
             && data.keys().size() == 22;
    }

    // Function to check if the fields being updated by the owner in their profile are allowed.
    function isAllowedOwnerProfileFieldsUpdate(newData, existingData) {
        // Fields an owner IS allowed to change directly via profile update
        let modifiableByOwner = ['name', 'photoURL', 'photoStoragePath', 'activeTheme', 'updatedAt'];

        // Check if any fields *not* in modifiableByOwner AND *not* in existingData.keys() are being added
        if (newData.keys().toSet().difference(existingData.keys().toSet()).difference(modifiableByOwner.toSet()).size() > 0) {
            return false; // Trying to add a non-modifiable field
        }

        // Check if any existing fields *not* in modifiableByOwner are being changed
        let changedExistingSystemFields = existingData.keys().filter(key =>
            !(key in modifiableByOwner) && (key in newData) && newData[key] != existingData[key]
        );
        if (changedExistingSystemFields.size() > 0) {
            return false; // Trying to change a system-managed or immutable field
        }

        // Type checks for fields that can be modified
        return (newData.keys().has('name') ? (newData.name is string || newData.name == null) : true) &&
               (newData.keys().has('photoURL') ? (newData.photoURL is string || newData.photoURL == null) : true) &&
               (newData.keys().has('photoStoragePath') ? (newData.photoStoragePath is string || newData.photoStoragePath == null) : true) &&
               (newData.keys().has('activeTheme') ? newData.activeTheme is string : true) &&
               // If updatedAt is being written, it must be the server timestamp.
               // If not present in newData, it means it's not being updated by this operation.
               (newData.keys().has('updatedAt') ? newData.updatedAt == request.time : true);
    }

    function isValidTransactionData(data, operation) {
      let commonFields = ['userId', 'amount', 'type', 'status', 'date']; // userName, userEmail are optional for system txns
      let allCommonFieldsPresent = data.keys().hasAll(commonFields);

      let basicTypesCorrect = data.userId is string &&
                              (data.keys().has('userName') ? (data.userName is string || data.userName == null) : true) &&
                              (data.keys().has('userEmail') ? (data.userEmail is string || data.userEmail == null) : true) &&
                              data.amount is number && // Can be positive or negative
                              data.type is string &&
                              data.status is string && (data.status == 'pending' || data.status == 'completed' || data.status == 'failed') &&
                              (operation == 'create' ? data.date == request.time : data.date is timestamp);

      if (!allCommonFieldsPresent || !basicTypesCorrect) { return false; }

      if (data.type == 'redeem') {
        return data.keys().hasAll(['inrAmount', 'paymentMethod', 'paymentDetails']) &&
               data.inrAmount is number && data.inrAmount >= 0 &&
               data.paymentMethod is string && data.paymentDetails is map &&
               (operation == 'create' ? data.status == 'pending' : true); // Redeem requests start as pending
      }
      if (data.type == 'p2p_send' || data.type == 'p2p_receive') {
        return data.keys().hasAll(['relatedUserId']) && // relatedUserName is optional but good to have
               data.relatedUserId is string &&
               (data.keys().has('relatedUserName') ? (data.relatedUserName is string || data.relatedUserName == null) : true);
      }
      // For other types, check necessary fields. Example: booster_purchase needs 'details'
      if (data.type == 'booster_purchase' || data.type == 'theme_purchase' || data.type == 'achievement_reward' || data.type == 'quest_reward' || data.type == 'referral_bonus') {
        return data.keys().has('details') && data.details is string;
      }
      // Daily bonus and offline earnings don't need extra details from client.
      if (data.type == 'daily_bonus' || data.type == 'offline_earnings') {
          return true;
      }
      return false; // Unknown transaction type by default is not valid
    }

    function isValidMarqueeItem(data) {
      return data.text is string && data.text.size() > 0 && data.text.size() <= 200 &&
             (data.keys().has('createdAt') ? data.createdAt == request.time : true) && // On create
             (data.keys().has('updatedAt') ? data.updatedAt == request.time : true); // On update
    }

    function isSupportTicketOwner(ticketData) {
        return request.auth.uid == ticketData.userId;
    }

    function isValidSupportTicketData(data, operation) {
        let requiredFieldsOnCreate = ['userId', 'userName', 'userEmail', 'category', 'description', 'status', 'createdAt'];
        let validStatus = data.status == 'open' || data.status == 'pending' || data.status == 'resolved' || data.status == 'closed';

        if (operation == 'create') {
            return data.keys().hasAll(requiredFieldsOnCreate) &&
                   data.userId == request.auth.uid &&
                   data.userName is string && data.userName.size() > 0 &&
                   data.userEmail is string && data.userEmail.matches('.+@.+') &&
                   data.category is string && data.category.size() > 0 &&
                   data.description is string && data.description.size() > 0 &&
                   data.status == 'open' && // New tickets are always 'open'
                   data.createdAt == request.time;
        }
        if (operation == 'update') {
            // Admin can update status and adminResponse
            return validStatus &&
                   (data.keys().has('adminResponse') ? data.adminResponse is string : true) &&
                   data.updatedAt == request.time;
        }
        return false;
    }

    function isValidUserQuestDocument(newData, existingData) {
        // Primarily for creation or ensuring structure for read
        if (existingData == null) { // Creation
            return newData.keys().hasAll(['lastQuestRefresh', 'activeDailyQuestIds']) &&
                   newData.lastQuestRefresh == request.time &&
                   newData.activeDailyQuestIds is list;
        }
        // For updates, mainly lastQuestRefresh and activeDailyQuestIds might change by system
        return newData.lastQuestRefresh is timestamp && newData.activeDailyQuestIds is list;
    }

    function isValidDailyQuestSubDocument(newData, existingData) {
        let requiredFields = ['definition', 'progress', 'completed', 'claimed', 'assignedAt'];
        if (!newData.keys().hasAll(requiredFields)) return false;

        if (existingData == null) { // Creation
            return newData.definition is map && // definition should be a map copy of QuestDefinition
                   newData.progress == 0 &&
                   newData.completed == false &&
                   newData.claimed == false &&
                   newData.assignedAt == request.time;
        }
        // Updates by user/system: progress, completed, claimed
        return newData.definition is map && // Should not change
               newData.progress is number && newData.progress >= 0 &&
               newData.completed is bool &&
               newData.claimed is bool &&
               newData.assignedAt is timestamp; // Should not change
    }

    function isValidAdminActionLog(data) {
        return data.keys().hasAll(['adminId', 'adminEmail', 'actionType', 'targetType', 'targetId', 'timestamp']) &&
               data.adminId == request.auth.uid && // Action must be logged by the performing admin
               data.adminEmail == request.auth.token.email &&
               data.actionType is string &&
               data.targetType is string &&
               data.targetId is string &&
               data.timestamp == request.time && // Logged at the time of action
               (data.keys().has('details') ? (data.details is map || data.details is string) : true); // Details are optional
    }

    // --- Rules for Collections ---
    match /users/{userId} {
      allow read: if request.auth.uid != null; // Any authenticated user can read basic user profiles if isPublicUserProfile passes.
      allow get: if request.auth.uid != null && (isOwner(userId) || isAdmin() || isPublicUserProfile(resource.data));

      // User can create their own document if data is valid.
      allow create: if isOwner(userId) && isValidNewUserDocument(request.resource.data);

      allow update: if isAdmin() || // Admins can update any field.
                      // Owner can update specific profile fields as defined in the helper.
                      (isOwner(userId) && isAllowedOwnerProfileFieldsUpdate(request.resource.data, resource.data)) ||
                      // Non-owner (sender in P2P) can update ONLY recipient's balance (increment) and updatedAt.
                      (request.auth.uid != null && request.auth.uid != userId &&
                       request.resource.data.keys().hasAll(['balance', 'updatedAt']) &&
                       request.resource.data.keys().size() == 2 &&
                       request.resource.data.balance is number &&
                       request.resource.data.balance > resource.data.balance && // Must be an increment
                       request.resource.data.updatedAt == request.time);
      allow delete: if isAdmin(); // Only admins can delete user accounts.
    }

    match /transactions/{transactionId} {
      allow read, list: if request.auth.uid != null && (isOwner(resource.data.userId) || isAdmin());
      allow create: if request.auth.uid != null &&
                       isValidTransactionData(request.resource.data, 'create') &&
                       (
                         // User can create their own transaction
                         (isOwner(request.resource.data.userId)) ||
                         // Sender can create a 'p2p_receive' transaction for the recipient
                         (request.resource.data.type == 'p2p_receive' &&
                          request.resource.data.relatedUserId == request.auth.uid && // sender is the relatedUserId
                          request.resource.data.userId != request.auth.uid // recipient is the main userId
                         )
                       );
      allow update: if isAdmin() && // Admins can update status (e.g., for redeem requests)
                       (request.resource.data.status is string && (request.resource.data.status == 'completed' || request.resource.data.status == 'failed')) &&
                       request.resource.data.updatedAt == request.time;
      allow delete: if isAdmin();
    }

    match /marquee_items/{itemId} {
      allow read: if true; // Marquee items are public.
      allow list: if true;
      allow create, update, delete: if isAdmin() && isValidMarqueeItem(request.resource.data);
    }

    match /faqs/{faqId} {
        allow read: if true; // FAQs are public
        allow list: if true;
        allow create, update, delete: if isAdmin(); // Admin can manage FAQs
    }

    match /support_tickets/{ticketId} {
        allow read: if request.auth.uid != null && (isSupportTicketOwner(resource.data) || isAdmin());
        allow list: if request.auth.uid != null && isAdmin(); // Only admin can list all tickets
        allow create: if request.auth.uid != null && isValidSupportTicketData(request.resource.data, 'create') && isSupportTicketOwner(request.resource.data);
        allow update: if request.auth.uid != null && isAdmin() && isValidSupportTicketData(request.resource.data, 'update');
        allow delete: if request.auth.uid != null && isAdmin();
    }

    match /user_quests/{userId} {
        allow read, update: if isOwner(userId) || isAdmin();
        // Creation of user_quests document might happen implicitly with first daily_quest or explicitly
        allow create: if isOwner(userId) && isValidUserQuestDocument(request.resource.data, null);

        match /daily_quests/{questId} {
            allow read: if isOwner(userId) || isAdmin();
            allow create: if isOwner(userId) && isValidDailyQuestSubDocument(request.resource.data, null);
            allow update: if isOwner(userId) && isValidDailyQuestSubDocument(request.resource.data, resource.data);
            allow delete: if isAdmin(); // Or if logic requires user to delete/reset (rare)
        }
    }

    match /admin_actions/{logId} {
        allow read, list: if isAdmin(); // Only admins can read action logs
        allow create: if isAdmin() && isValidAdminActionLog(request.resource.data);
        allow update, delete: if false; // Logs should be immutable
    }
  }
}

    