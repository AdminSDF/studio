
rules_version = '2';

service cloud.firestore {
  match /databases/{database}/documents {

    // Helper Functions
    function isAuthenticated() {
      return request.auth != null;
    }

    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    function isAdmin() {
      // admin UID: QgyeVb3LUgWOkMrakhCUgb5ZtwN2
      return request.auth.uid == 'QgyeVb3LUgWOkMrakhCUgb5ZtwN2';
    }

    function isValidEmail(email) {
      return email is string && email.matches('^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\\.[a-zA-Z]{2,}$');
    }

    function isValidNewUserDocument(data, userIdAuth) {
      let now = request.time;
      return data.keys().hasOnly([
          'balance', 'tapCountToday', 'lastTapDate', 'currentEnergy', 'maxEnergy',
          'tapPower', 'lastEnergyUpdate', 'boostLevels', 'lastLoginBonusClaimed',
          'referredBy', 'createdAt', 'name', 'email', 'photoURL', 'photoStoragePath',
          'completedAchievements', 'referralsMadeCount', 'activeTheme', 'unlockedThemes',
          'frenzyEndTime', 'frenzyMultiplier', 'energySurgeEndTime', 'updatedAt'
        ]) &&
        (data.balance is number && (data.balance == 0 || data.balance > 0)) &&
        data.tapCountToday is number && data.tapCountToday == 0 &&
        data.lastTapDate is string &&
        data.currentEnergy is number && data.currentEnergy > 0 &&
        data.maxEnergy is number && data.maxEnergy >= data.currentEnergy &&
        data.tapPower is number && data.tapPower > 0 &&
        data.lastEnergyUpdate == now &&
        data.boostLevels is map && data.boostLevels.size() == 0 &&
        (data.lastLoginBonusClaimed == null || data.lastLoginBonusClaimed is timestamp) && // Can be null
        (data.referredBy == null || (data.referredBy is string && data.referredBy != userIdAuth)) && // Can be null, cannot be self
        data.createdAt == now &&
        (data.name is string && data.name.size() > 0) && // Name is required
        data.email is string && data.email == request.auth.token.email && isValidEmail(data.email) &&
        (data.photoURL == null || (data.photoURL is string && data.photoURL.matches('https?://.+'))) &&
        (data.photoStoragePath == null || data.photoStoragePath is string) &&
        data.completedAchievements is map && data.completedAchievements.size() == 0 &&
        data.referralsMadeCount is number && data.referralsMadeCount == 0 &&
        data.activeTheme is string &&
        data.unlockedThemes is list && data.unlockedThemes[0] == data.activeTheme && // First theme is default and active
        (data.frenzyEndTime == null || data.frenzyEndTime is timestamp) &&
        (data.frenzyMultiplier == null || data.frenzyMultiplier is number) &&
        (data.energySurgeEndTime == null || data.energySurgeEndTime is timestamp) &&
        (data.updatedAt == null || data.updatedAt == now);
    }

    function isValidUserUpdate(newData, oldData, authUid, userId) {
      let allowedToUpdateByOwner = [
        'name', 'photoURL', 'photoStoragePath', 'activeTheme', 'unlockedThemes',
        'balance', 'tapCountToday', 'lastTapDate', 'currentEnergy', 'maxEnergy', 'tapPower',
        'lastEnergyUpdate', 'boostLevels', 'lastLoginBonusClaimed', 'completedAchievements',
        'frenzyEndTime', 'frenzyMultiplier', 'energySurgeEndTime', 'updatedAt'
      ];
      let immutableByUser = ['email', 'createdAt', 'referredBy', 'referralsMadeCount']; // User cannot change these directly

      let changes = newData.diff(oldData).affectedKeys;

      return newData.updatedAt == request.time &&
             changes.hasOnly(allowedToUpdateByOwner) &&
             immutableByUser.intersect(changes).size() == 0 &&
             (newData.name is string && newData.name.size() > 0) && // Name must be non-empty string
             (newData.photoURL == null || (newData.photoURL is string && newData.photoURL.matches('https?://.+'))) &&
             (newData.photoStoragePath == null || newData.photoStoragePath is string) &&
             newData.activeTheme is string &&
             newData.unlockedThemes is list &&
             newData.balance is number && newData.balance >= 0 &&
             newData.tapCountToday is number && newData.tapCountToday >= 0 &&
             newData.lastTapDate is string &&
             newData.currentEnergy is number && newData.currentEnergy >= 0 && newData.currentEnergy <= (newData.maxEnergy * 1.1) && // Allow overfill slightly
             newData.maxEnergy is number && (isOwner(userId) ? newData.maxEnergy >= oldData.maxEnergy : newData.maxEnergy == oldData.maxEnergy) && // Max energy should not decrease by user
             newData.tapPower is number && (isOwner(userId) ? newData.tapPower >= oldData.tapPower : newData.tapPower == oldData.tapPower) && // Tap power should not decrease by user
             newData.lastEnergyUpdate is timestamp &&
             newData.boostLevels is map &&
             (newData.lastLoginBonusClaimed == null || newData.lastLoginBonusClaimed is timestamp) &&
             newData.completedAchievements is map &&
             (newData.frenzyEndTime == null || newData.frenzyEndTime is timestamp) &&
             (newData.frenzyMultiplier == null || newData.frenzyMultiplier is number) &&
             (newData.energySurgeEndTime == null || newData.energySurgeEndTime is timestamp);
    }

    function isPublicUserProfile(data) {
      // Minimal fields needed for leaderboard or public profile view
      return (data.name is string || data.name == null) && // Name can be null for "Anonymous"
             data.balance is number &&
             (data.photoURL == null || data.photoURL is string);
    }

    match /users/{userId} {
      allow read: if isAuthenticated(); // Allows fetching user docs for P2P checks / leaderboard
      allow get: if isAuthenticated();  // Simplified for now. For tighter control: isOwner(userId) || isAdmin() || isPublicUserProfile(resource.data);

      allow create: if isAuthenticated() && isOwner(userId) && isValidNewUserDocument(request.resource.data, request.auth.uid);

      allow update: if
        (isOwner(userId) && isValidUserUpdate(request.resource.data, resource.data, request.auth.uid, userId)) ||
        // Condition for P2P: Allow sender (request.auth.uid) to update recipient's (userId) balance
        (isAuthenticated() && !isOwner(userId) && // Acting user is not the owner of this document
          request.resource.data.keys().hasOnly(['balance', 'updatedAt']) && // Only balance and updatedAt can be changed
          request.resource.data.balance is number &&
          (request.resource.data.balance > resource.data.balance || request.resource.data.balance < resource.data.balance) && // Ensure balance actually changes (recipient increases, sender decreases on their own doc)
          request.resource.data.updatedAt == request.time
        ) ||
        isAdmin(); // Admin can update any user field (consider more granular admin rules if needed)

      allow delete: if isAdmin();
    }

    function isValidTransactionCreate(data, authUid) {
      let commonFields = ['userId', 'userName', 'userEmail', 'amount', 'type', 'status', 'date', 'details', 'relatedUserId', 'relatedUserName', 'updatedAt'];
      let redeemFields = commonFields.concat(['inrAmount', 'paymentMethod', 'paymentDetails']);

      return data.userId == authUid &&
             data.amount is number && (data.amount != 0) && // Amount cannot be zero
             data.type is string && data.type != "" &&
             data.status is string && (data.status == 'pending' || data.status == 'completed' || data.status == 'failed') &&
             data.date == request.time &&
             (data.updatedAt == null || data.updatedAt == request.time) &&
             (data.details == null || data.details is string) &&
             (data.userName == null || data.userName is string) &&
             (data.userEmail == null || isValidEmail(data.userEmail)) &&
             (data.relatedUserId == null || data.relatedUserId is string) &&
             (data.relatedUserName == null || data.relatedUserName is string) &&
             (data.type != 'redeem' || (
                data.inrAmount is number && data.inrAmount >= 0 &&
                data.paymentMethod is string && data.paymentMethod != "" &&
                data.paymentDetails is map && data.paymentDetails.size() > 0 &&
                data.keys().hasOnly(redeemFields) // Strict check for redeem
             )) &&
             (data.type == 'redeem' || data.keys().hasOnly(commonFields)); // Less strict for non-redeem if some optional fields are missing
    }

    function isValidP2PReceiveTransaction(data, authUid) { // authUid is the sender
      return data.userId is string && data.userId != "" && data.userId != authUid && // Recipient's ID, not sender
             data.relatedUserId is string && data.relatedUserId == authUid && // Sender's ID must be current auth user
             data.amount is number && data.amount > 0 &&
             data.type == 'p2p_receive' &&
             data.status == 'completed' &&
             data.date == request.time &&
             (data.updatedAt == null || data.updatedAt == request.time) &&
             data.details is string &&
             (data.userName == null || data.userName is string) && // Recipient's name
             (data.userEmail == null || isValidEmail(data.userEmail)) && // Recipient's email
             (data.relatedUserName == null || data.relatedUserName is string) && // Sender's name
             // Ensures only expected fields for p2p_receive
             data.keys().hasOnly(['userId', 'userName', 'userEmail', 'amount', 'type', 'status', 'date', 'details', 'relatedUserId', 'relatedUserName', 'updatedAt']);
    }

    match /transactions/{transactionId} {
      allow read: if isAuthenticated() && (isOwner(resource.data.userId) || isAdmin());
      allow list: if isAuthenticated() && (request.query.limit <= 100 && (request.query.offset == null || request.query.offset is number) &&
                                        (request.query.orderBy[0][0] == 'date' && request.query.orderBy[0][1] == 'desc') && // Ensure specific ordering
                                        request.resource.data.userId == request.auth.uid // User can only list their own transactions
                                       ) || isAdmin();


      allow create: if isAuthenticated() &&
                       // Case 1: User is creating their own transaction (e.g., redeem, booster_purchase, p2p_send)
                       (request.resource.data.userId == request.auth.uid &&
                        isValidTransactionCreate(request.resource.data, request.auth.uid)
                       ) ||
                       // Case 2: Sender (request.auth.uid) is creating a 'p2p_receive' transaction for the Recipient (request.resource.data.userId)
                       (request.resource.data.type == 'p2p_receive' &&
                        request.resource.data.userId != request.auth.uid && // userId on transaction is recipient
                        request.resource.data.relatedUserId == request.auth.uid && // relatedUserId is the sender
                        isValidP2PReceiveTransaction(request.resource.data, request.auth.uid)
                       );

      allow update: if isAdmin() &&
                       request.resource.data.updatedAt == request.time &&
                       // Admin can only update status and optionally adminNotes
                       request.resource.data.diff(resource.data).affectedKeys.hasOnly(['status', 'updatedAt', 'adminNotes']); // Assuming adminNotes is a field

      allow delete: if isAdmin();
    }

    match /marquee_items/{itemId} {
      allow read: if isAuthenticated();
      allow list: if isAuthenticated(); // Ensure proper indexing for orderBy if used
      allow create, update, delete: if isAdmin();
    }

    match /faqs/{faqId} {
        allow read: if isAuthenticated();
        allow list: if isAuthenticated(); // Ensure proper indexing for orderBy if used
        allow create, update, delete: if isAdmin();
    }

    match /user_quests/{userId} {
        allow read, write: if isAuthenticated() && isOwner(userId);
        allow get: if isAuthenticated() && (isOwner(userId) || isAdmin());
    }
    match /user_quests/{userId}/daily_quests/{questId} {
        allow read, write: if isAuthenticated() && isOwner(userId);
        allow get: if isAuthenticated() && (isOwner(userId) || isAdmin());
    }

    match /support_tickets/{ticketId} {
      allow read: if isAuthenticated() && (isOwner(resource.data.userId) || isAdmin());
      allow create: if isAuthenticated() &&
                       request.resource.data.userId == request.auth.uid &&
                       request.resource.data.status == 'open' && // Initial status must be 'open'
                       request.resource.data.createdAt == request.time &&
                       (request.resource.data.updatedAt == null || request.resource.data.updatedAt == request.time) &&
                       request.resource.data.adminResponse == null && // Admin response should be null at creation
                       request.resource.data.keys().hasOnly(['userId', 'userName', 'userEmail', 'category', 'description', 'status', 'createdAt', 'updatedAt', 'adminResponse']) &&
                       request.resource.data.category is string && request.resource.data.description is string;

      allow update: if isAdmin() &&
                       request.resource.data.updatedAt == request.time &&
                       // Admin can only update status and adminResponse
                       request.resource.data.diff(resource.data).affectedKeys.hasOnly(['status', 'adminResponse', 'updatedAt']);

      allow delete: if isAdmin();
    }

    match /admin_actions/{logId} {
        allow read, list: if isAdmin(); // Admins can read/list logs
        allow create: if isAdmin() &&
                         request.resource.data.adminId == request.auth.uid &&
                         request.resource.data.timestamp == request.time;
        allow update, delete: if false; // Logs are immutable
    }
  }
}

    